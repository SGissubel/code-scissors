{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { pipe, of, EMPTY, concat, Observable } from 'rxjs';\nimport { map, distinctUntilChanged, filter, withLatestFrom, scan, observeOn, switchMap, startWith, shareReplay, groupBy, mergeMap, debounceTime } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire/compat';\nimport { isSupported } from 'firebase/remote-config';\nimport firebase from 'firebase/compat/app'; // DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/remote-config, so Proxy can work with proxy-polyfill in Internet Explorer\n\nconst proxyPolyfillCompat = {\n  app: null,\n  settings: null,\n  defaultConfig: null,\n  fetchTimeMillis: null,\n  lastFetchStatus: null,\n  activate: null,\n  ensureInitialized: null,\n  fetch: null,\n  fetchAndActivate: null,\n  getAll: null,\n  getBoolean: null,\n  getNumber: null,\n  getString: null,\n  getValue: null,\n  setLogLevel: null\n};\nconst SETTINGS = /*#__PURE__*/new InjectionToken('angularfire2.remoteConfig.settings');\nconst DEFAULTS = /*#__PURE__*/new InjectionToken('angularfire2.remoteConfig.defaultConfig');\nconst AS_TO_FN = {\n  strings: 'asString',\n  numbers: 'asNumber',\n  booleans: 'asBoolean'\n};\nconst STATIC_VALUES = {\n  numbers: 0,\n  booleans: false,\n  strings: undefined\n}; // TODO look into the types here, I don't like the anys\n\nconst proxyAll = (observable, as) => new Proxy(observable.pipe(mapToObject(as)), {\n  get: (self, name) => self[name] || observable.pipe(map(all => all.find(p => p.key === name)), map(param => param ? param[AS_TO_FN[as]]() : STATIC_VALUES[as]), distinctUntilChanged())\n}); // TODO export as implements Partial<...> so minor doesn't break us\n\n\nclass Value {\n  // tslint:disable-next-line:variable-name\n  constructor(_source, _value) {\n    this._source = _source;\n    this._value = _value;\n  }\n\n  asBoolean() {\n    return ['1', 'true', 't', 'y', 'yes', 'on'].indexOf(this._value.toLowerCase()) > -1;\n  }\n\n  asString() {\n    return this._value;\n  }\n\n  asNumber() {\n    return Number(this._value) || 0;\n  }\n\n  getSource() {\n    return this._source;\n  }\n\n} // SEMVER use ConstructorParameters when we can support Typescript 3.6\n\n\nclass Parameter extends Value {\n  constructor(key, fetchTimeMillis, source, value) {\n    super(source, value);\n    this.key = key;\n    this.fetchTimeMillis = fetchTimeMillis;\n  }\n\n} // If it's a Parameter array, test any, else test the individual Parameter\n\n\nconst filterTest = fn => filter(it => Array.isArray(it) ? it.some(fn) : fn(it)); // Allow the user to bypass the default values and wait till they get something from the server, even if it's a cached copy;\n// if used in conjuntion with first() it will only fetch RC values from the server if they aren't cached locally\n\n\nconst filterRemote = () => filterTest(p => p.getSource() === 'remote'); // filterFresh allows the developer to effectively set up a maximum cache time\n\n\nconst filterFresh = howRecentInMillis => filterTest(p => p.fetchTimeMillis + howRecentInMillis >= new Date().getTime()); // I ditched loading the defaults into RC and a simple map for scan since we already have our own defaults implementation.\n// The idea here being that if they have a default that never loads from the server, they will be able to tell via fetchTimeMillis\n// on the Parameter. Also if it doesn't come from the server it won't emit again in .changes, due to the distinctUntilChanged,\n// which we can simplify to === rather than deep comparison\n\n\nconst scanToParametersArray = remoteConfig => pipe(withLatestFrom(remoteConfig), scan((existing, [all, rc]) => {\n  // SEMVER use \"new Set\" to unique once we're only targeting es6\n  // at the scale we expect remote config to be at, we probably won't see a performance hit from this unoptimized uniqueness\n  // implementation.\n  // const allKeys = [...new Set([...existing.map(p => p.key), ...Object.keys(all)])];\n  const allKeys = [...existing.map(p => p.key), ...Object.keys(all)].filter((v, i, a) => a.indexOf(v) === i);\n  return allKeys.map(key => {\n    const updatedValue = all[key];\n    return updatedValue ? new Parameter(key, rc ? rc.fetchTimeMillis : -1, updatedValue.getSource(), updatedValue.asString()) : existing.find(p => p.key === key);\n  });\n}, []));\n\nlet AngularFireRemoteConfig = /*#__PURE__*/(() => {\n  class AngularFireRemoteConfig {\n    constructor(options, name, settings, defaultConfig, zone, schedulers, // tslint:disable-next-line:ban-types\n    platformId) {\n      this.zone = zone;\n      const remoteConfig$ = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => isSupported()), switchMap(isSupported => isSupported ? import('firebase/compat/remote-config') : EMPTY), map(() => ɵfirebaseAppFactory(options, zone, name)), map(app => ɵcacheInstance(`${app.name}.remote-config`, 'AngularFireRemoteConfig', app.name, () => {\n        const rc = app.remoteConfig();\n\n        if (settings) {\n          rc.settings = settings;\n        }\n\n        if (defaultConfig) {\n          rc.defaultConfig = defaultConfig;\n        }\n\n        return rc;\n      }, [settings, defaultConfig])), startWith(undefined), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      const loadedRemoteConfig$ = remoteConfig$.pipe(filter(rc => !!rc));\n      const default$ = of(Object.keys(defaultConfig || {}).reduce((c, k) => Object.assign(Object.assign({}, c), {\n        [k]: new Value('default', defaultConfig[k].toString())\n      }), {})); // we should filter out the defaults we provided to RC, since we have our own implementation\n      // that gives us a -1 for fetchTimeMillis (so filterFresh can filter them out)\n\n      const filterOutDefaults = map(all => Object.keys(all).filter(key => all[key].getSource() !== 'default').reduce((acc, key) => Object.assign(Object.assign({}, acc), {\n        [key]: all[key]\n      }), {}));\n      const existing$ = loadedRemoteConfig$.pipe(switchMap(rc => rc.activate().then(() => rc.ensureInitialized()).then(() => rc.getAll())), filterOutDefaults);\n      const fresh$ = loadedRemoteConfig$.pipe(switchMap(rc => zone.runOutsideAngular(() => rc.fetchAndActivate().then(() => rc.ensureInitialized()).then(() => rc.getAll()))), filterOutDefaults);\n      this.parameters = concat(default$, existing$, fresh$).pipe(scanToParametersArray(remoteConfig$), keepUnstableUntilFirst, shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n      this.changes = this.parameters.pipe(switchMap(params => of(...params)), groupBy(param => param.key), mergeMap(group => group.pipe(distinctUntilChanged())));\n      this.strings = proxyAll(this.parameters, 'strings');\n      this.booleans = proxyAll(this.parameters, 'booleans');\n      this.numbers = proxyAll(this.parameters, 'numbers');\n      return ɵlazySDKProxy(this, loadedRemoteConfig$, zone);\n    }\n\n  }\n\n  AngularFireRemoteConfig.ɵfac = function AngularFireRemoteConfig_Factory(t) {\n    return new (t || AngularFireRemoteConfig)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(DEFAULTS, 8), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(PLATFORM_ID));\n  };\n\n  AngularFireRemoteConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFireRemoteConfig,\n    factory: AngularFireRemoteConfig.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFireRemoteConfig;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst budget = interval => source => new Observable(observer => {\n  let timedOut = false; // TODO use scheduler task rather than settimeout\n\n  const timeout = setTimeout(() => {\n    observer.complete();\n    timedOut = true;\n  }, interval);\n  return source.subscribe({\n    next(val) {\n      if (!timedOut) {\n        observer.next(val);\n      }\n    },\n\n    error(err) {\n      if (!timedOut) {\n        clearTimeout(timeout);\n        observer.error(err);\n      }\n    },\n\n    complete() {\n      if (!timedOut) {\n        clearTimeout(timeout);\n        observer.complete();\n      }\n    }\n\n  });\n});\n\nconst typedMethod = it => {\n  switch (typeof it) {\n    case 'string':\n      return 'asString';\n\n    case 'boolean':\n      return 'asBoolean';\n\n    case 'number':\n      return 'asNumber';\n\n    default:\n      return 'asString';\n  }\n};\n\nfunction scanToObject(to = 'strings') {\n  return pipe( // TODO cleanup\n  scan((c, p) => Object.assign(Object.assign({}, c), {\n    [p.key]: typeof to === 'object' ? p[typedMethod(to[p.key])]() : p[AS_TO_FN[to]]()\n  }), typeof to === 'object' ? to : {}), debounceTime(1), budget(10), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));\n}\n\nfunction mapToObject(to = 'strings') {\n  return pipe( // TODO this is getting a little long, cleanup\n  map(params => params.reduce((c, p) => Object.assign(Object.assign({}, c), {\n    [p.key]: typeof to === 'object' ? p[typedMethod(to[p.key])]() : p[AS_TO_FN[to]]()\n  }), typeof to === 'object' ? to : {})), distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)));\n}\n\n/*#__PURE__*/\nɵapplyMixins(AngularFireRemoteConfig, [proxyPolyfillCompat]);\nlet AngularFireRemoteConfigModule = /*#__PURE__*/(() => {\n  class AngularFireRemoteConfigModule {\n    constructor() {\n      firebase.registerVersion('angularfire', VERSION.full, 'rc-compat');\n    }\n\n  }\n\n  AngularFireRemoteConfigModule.ɵfac = function AngularFireRemoteConfigModule_Factory(t) {\n    return new (t || AngularFireRemoteConfigModule)();\n  };\n\n  AngularFireRemoteConfigModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireRemoteConfigModule\n  });\n  AngularFireRemoteConfigModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireRemoteConfig]\n  });\n  return AngularFireRemoteConfigModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireRemoteConfig, AngularFireRemoteConfigModule, DEFAULTS, Parameter, SETTINGS, Value, budget, filterFresh, filterRemote, mapToObject, scanToObject }; //# sourceMappingURL=angular-fire-compat-remote-config.js.map","map":null,"metadata":{},"sourceType":"module"}