{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Optional, Inject, NgModule } from '@angular/core';\nimport { of, EMPTY, Observable } from 'rxjs';\nimport { switchMap, map, shareReplay, tap, first } from 'rxjs/operators';\nimport * as i1 from '@angular/fire/compat';\nimport { ɵcacheInstance, ɵlazySDKProxy, ɵapplyMixins } from '@angular/fire/compat';\nimport { isPlatformBrowser } from '@angular/common';\nimport firebase from 'firebase/compat/app';\nimport { VERSION } from '@angular/fire'; // DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/performance, so Proxy can work with proxy-polyfill in Internet Explorer\n\nconst proxyPolyfillCompat = {\n  app: null,\n  trace: null,\n  instrumentationEnabled: null,\n  dataCollectionEnabled: null\n};\nconst INSTRUMENTATION_ENABLED = /*#__PURE__*/new InjectionToken('angularfire2.performance.instrumentationEnabled');\nconst DATA_COLLECTION_ENABLED = /*#__PURE__*/new InjectionToken('angularfire2.performance.dataCollectionEnabled');\nlet AngularFirePerformance = /*#__PURE__*/(() => {\n  class AngularFirePerformance {\n    constructor(app, instrumentationEnabled, dataCollectionEnabled, zone, // tslint:disable-next-line:ban-types\n    platformId) {\n      this.zone = zone;\n      this.performance = of(undefined).pipe(switchMap(() => isPlatformBrowser(platformId) ? zone.runOutsideAngular(() => import('firebase/compat/performance')) : EMPTY), map(() => ɵcacheInstance(`performance`, 'AngularFirePerformance', app.name, () => {\n        const performance = zone.runOutsideAngular(() => app.performance());\n\n        if (instrumentationEnabled === false) {\n          performance.instrumentationEnabled = false;\n        }\n\n        if (dataCollectionEnabled === false) {\n          performance.dataCollectionEnabled = false;\n        }\n\n        return performance;\n      }, [instrumentationEnabled, dataCollectionEnabled])), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      return ɵlazySDKProxy(this, this.performance, zone);\n    }\n\n  }\n\n  AngularFirePerformance.ɵfac = function AngularFirePerformance_Factory(t) {\n    return new (t || AngularFirePerformance)(i0.ɵɵinject(i1.FirebaseApp), i0.ɵɵinject(INSTRUMENTATION_ENABLED, 8), i0.ɵɵinject(DATA_COLLECTION_ENABLED, 8), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID));\n  };\n\n  AngularFirePerformance.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFirePerformance,\n    factory: AngularFirePerformance.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFirePerformance;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst trace$ = traceId => {\n  var _a;\n\n  if (typeof window !== 'undefined' && ((_a = window.performance) === null || _a === void 0 ? void 0 : _a.mark)) {\n    const entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n    const startMarkName = `_${traceId}Start[${entries.length}]`;\n    const endMarkName = `_${traceId}End[${entries.length}]`;\n    return new Observable(emitter => {\n      window.performance.mark(startMarkName);\n      emitter.next();\n      return {\n        unsubscribe: () => {\n          window.performance.mark(endMarkName);\n          window.performance.measure(traceId, startMarkName, endMarkName);\n        }\n      };\n    });\n  } else {\n    return EMPTY;\n  }\n};\n\nconst traceUntil = (name, test, options) => source$ => new Observable(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(tap(a => test(a) && traceSubscription.unsubscribe(), () => {}, () => options && options.orComplete && traceSubscription.unsubscribe())).subscribe(subscriber);\n});\n\nconst traceWhile = (name, test, options) => source$ => new Observable(subscriber => {\n  let traceSubscription;\n  return source$.pipe(tap(a => {\n    if (test(a)) {\n      traceSubscription = traceSubscription || trace$(name).subscribe();\n    } else {\n      if (traceSubscription) {\n        traceSubscription.unsubscribe();\n      }\n\n      traceSubscription = undefined;\n    }\n  }, () => {}, () => options && options.orComplete && traceSubscription && traceSubscription.unsubscribe())).subscribe(subscriber);\n});\n\nconst traceUntilComplete = name => source$ => new Observable(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(tap(() => {}, () => {}, () => traceSubscription.unsubscribe())).subscribe(subscriber);\n});\n\nconst traceUntilFirst = name => source$ => new Observable(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(tap(() => traceSubscription.unsubscribe(), () => {}, () => {})).subscribe(subscriber);\n});\n\nconst trace = name => source$ => new Observable(subscriber => {\n  const traceSubscription = trace$(name).subscribe();\n  return source$.pipe(tap(() => traceSubscription.unsubscribe(), () => {}, () => traceSubscription.unsubscribe())).subscribe(subscriber);\n});\n\n/*#__PURE__*/\nɵapplyMixins(AngularFirePerformance, [proxyPolyfillCompat]);\nconst IS_STABLE_START_MARK = 'Zone';\nconst IS_STABLE_END_MARK = '_isStableEnd';\nlet PerformanceMonitoringService = /*#__PURE__*/(() => {\n  class PerformanceMonitoringService {\n    constructor(appRef) {\n      var _a;\n\n      if (typeof window !== 'undefined' && ((_a = window.performance) === null || _a === void 0 ? void 0 : _a.mark)) {\n        this.disposable = appRef.isStable.pipe(first(it => it), tap(() => {\n          window.performance.mark(IS_STABLE_END_MARK);\n          window.performance.measure('isStable', IS_STABLE_START_MARK, IS_STABLE_END_MARK);\n        })).subscribe();\n      }\n    }\n\n    ngOnDestroy() {\n      if (this.disposable) {\n        this.disposable.unsubscribe();\n      }\n    }\n\n  }\n\n  PerformanceMonitoringService.ɵfac = function PerformanceMonitoringService_Factory(t) {\n    return new (t || PerformanceMonitoringService)(i0.ɵɵinject(i0.ApplicationRef));\n  };\n\n  PerformanceMonitoringService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PerformanceMonitoringService,\n    factory: PerformanceMonitoringService.ɵfac\n  });\n  return PerformanceMonitoringService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AngularFirePerformanceModule = /*#__PURE__*/(() => {\n  class AngularFirePerformanceModule {\n    constructor(perf, _) {\n      firebase.registerVersion('angularfire', VERSION.full, 'perf-compat'); // call anything here to get perf loading\n      // tslint:disable-next-line:no-unused-expression\n\n      perf.dataCollectionEnabled.then(() => {});\n    }\n\n  }\n\n  AngularFirePerformanceModule.ɵfac = function AngularFirePerformanceModule_Factory(t) {\n    return new (t || AngularFirePerformanceModule)(i0.ɵɵinject(AngularFirePerformance), i0.ɵɵinject(PerformanceMonitoringService, 8));\n  };\n\n  AngularFirePerformanceModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFirePerformanceModule\n  });\n  AngularFirePerformanceModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFirePerformance]\n  });\n  return AngularFirePerformanceModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFirePerformance, AngularFirePerformanceModule, DATA_COLLECTION_ENABLED, INSTRUMENTATION_ENABLED, PerformanceMonitoringService, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile }; //# sourceMappingURL=angular-fire-compat-performance.js.map","map":null,"metadata":{},"sourceType":"module"}